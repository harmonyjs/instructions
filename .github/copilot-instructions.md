<!-- Generated by https://github.com/harmonyjs/instructions -->

Here are some instructions that you should follow when generating code. Please follow these rules carefully and do not deviate from them. If you have any questions or are unable to comply with any of these instructions, please explain the reason to the user.

```yaml
ruleset:
  version: "2025-08-24"
  priority: critical

  # Here MUST/SHOULD/MAY semantics is used
  # @see https://www.rfc-editor.org/rfc/rfc2119
  semantics: "RFC-2119"

  conflict_resolution: >
    When rules conflict, groups listed first take precedence; within a group, MUST overrides SHOULD and MAY.

  groups:

    - title: Execution & Mindset
      rules:

        # Rationale: Focus keeps the codebase lean, reviewable, and maintainable.
        # Tags: yagni, minimalism, scope-control
        - title: Minimal, Purpose-Driven Implementation
          must:
            - Implement only what is strictly required to satisfy the task—no feature creep or speculative abstractions.

        # Rationale: Ensures structured reasoning, surfaces ambiguities, improves accuracy and repeatability.
        # Tags: thinking-tool, reasoning, analysis, copilot
        - title: Thinking Tool
          must:
            - Invoke the Thinking Tool on every new user request to analyze the task and draft a solution.

        # Rationale: Automatic resolution of routine errors accelerates development and reduces overhead.
        # Tags: autonomy, lint, typecheck, tests, maintenance
        - title: Autonomous Error Corrections
          must:
            - When lint, typecheck, or test errors are detected, immediately fix the underlying issues without asking permission.
          should:
            - Consult the user only for strategic or architectural decisions, not routine maintenance.

    - title: Code Design & Structure
      rules:

        # Rationale: Readable, documented code accelerates onboarding and refactors.
        # Tags: style, comments, pure-functions, documentation
        - title: Idiomatic, Well-Commented Code
          must:
            - Write clear TypeScript/JavaScript matching the existing style for indentation, quotes, and imports.
            - Favor pure functions; when side effects are unavoidable, document them explicitly.
          should:
            - Add JSDoc and, where it truly helps, small ASCII-art diagrams; avoid noisy diagrams that bloat diffs.

        # Rationale: Improves readability, testability, and maintainability.
        # Tags: srp, modularity, responsibility
        - title: Single Responsibility Principle
          must:
            - Ensure every function or module has one clear responsibility.
            - Split overly complex functions into smaller, focused units.

        # Rationale: Smaller units are easier to test, reason about, and reuse.
        # Tags: modularity, refactor, file-size
        - title: Modular Design & File Size Limits
          must:
            - Decompose logic into small self-contained modules/functions.
            - Keep each source file <= 200 lines; refactor or split when approaching the limit.

        # Rationale: Prevents needless complexity and keeps APIs straightforward.
        # Tags: abstraction, oop, modules
        - title: Avoid Hollow Static-Only Classes & Over-Abstraction
          must:
            - Do not wrap unrelated helpers in static-method classes; use plain modules or namespaces.
          should:
            - Introduce abstraction layers only when demonstrably necessary.

        # Rationale: Enforceable visibility yields clearer APIs and safer refactoring.
        # Tags: encapsulation, access-control, typescript, javascript
        - title: Use Proper Encapsulation, Not Underscore Prefixes
          must:
            - Do not use leading underscores (e.g., _foo) to signal privacy.
            - Enforce visibility via language constructs (private/protected, \#private fields), module scope, closures, or explicit access modifiers.
            - Separate public and private surfaces via exports or interface definitions.

        # Rationale: Controlled reuse reduces bugs without adding unnecessary layers.
        # Tags: dry, reusability, utilities
        - title: Extract Reusable Utilities
          should:
            - Identify repeated patterns and extract shared helpers/modules only when duplication recurs ≥2–3 times.

        # Rationale: Prevents bloated signatures, reduces cognitive load, improves decoupling.
        # Tags: functions, design, api, clean-code
        - title: Avoid Parameter Drilling
          must:
            - Functions declare and accept only the parameters they actually use.
            - Do not forward unused parameters through intermediate calls.
          should:
            - Share cross-cutting data via a typed context or dependency injection instead of drilling.

        # Rationale: Eliminates dead code, avoids unnecessary dependencies, keeps the codebase clean.
        # Tags: imports, cleanup, lint, exports
        - title: Remove Unused Code
          must:
            - Remove any variable, function, export, or module that is never used (and not imported for side effects).
            - Never leave unused exports in the codebase.
            - Eliminate dead code immediately upon detection rather than muting via underscores or pragmas.

    - title: Modules & Imports
      rules:

        # Rationale: Deterministic imports improve readability, bundling, and tooling.
        # Tags: imports, node, static, aliasing
        - title: Strict Import Conventions
          must:
            - Import Node built-in modules with the "node:" protocol.
            - Use "#" subpath aliases WHEN package.json#imports/TS/bundler are configured; otherwise use project-approved aliases or relative paths.
            - Prefer static imports; MAY use dynamic import() for lazy-loading/code-splitting with a short rationale comment.

        # Rationale: Eliminates dead code, avoids unnecessary dependencies, keeps the codebase clean.
        # Tags: imports, cleanup, lint
        - title: Remove Unused Variables and Imports
          must:
            - Remove any variable or module that is never used (and not imported for side effects) rather than muting via underscores or pragmas.

        # Rationale: Prevents fragile relative paths, enforces consistent module resolution.
        # Tags: imports, paths, modules
        - title: No Parent Directory Traversal in Imports
          must:
            - Never use "../" in import paths.
            - Use absolute imports, module aliases, or package.json#imports configuration instead.

        # Rationale: Simplifies module consumption, centralizes public API, improves discoverability.
        # Tags: barrel, exports, modules, structure
        - title: Barrel Files for Directory Exports
          must:
            - Create an index.ts (barrel file) in every directory that exports modules.
            - Re-export all public APIs through the barrel file.
            - Import from directories via their barrel files rather than reaching into internal files.

    - title: JavaScript/TypeScript Idioms
      rules:

        # Rationale: Promotes predictable behavior, performance, and maintainability.
        # Tags: javascript, async, errors, functional
        - title: Modern JavaScript Patterns
          must:
            - Prefer for…of loops or Array.map over forEach for iteration.
            - Avoid "return await"; USE it inside try/catch/finally when correct error/stack semantics are required.
            - Prefer typed errors and rethrow; log at process/service/module boundaries to avoid duplicate logs.
            - Minimize mutation; use a functional style.
          should:
            - Use Object.freeze/Object.seal only when justified, documenting each use.
            - Avoid argument forwarding anti-patterns.

        # Rationale: Transparency around side effects simplifies debugging and parallelization.
        # Tags: purity, side-effects, documentation
        - title: Pure Functions & Documented Side-Effects
          must:
            - Prefer pure functions by default.
            - When I/O or external mutation is necessary, document what is modified, why it's required, and safeguards applied.

        # Rationale: Type assertions can mask errors; explicit documentation ensures intentional usage.
        # Tags: typescript, type-safety, assertions, documentation
        - title: Document Type Assertions
          must:
            - Accompany every "as" type assertion with a comment explaining why it's safe and necessary.
            - Prefer type guards or proper typing over assertions when possible.

    - title: Testing
      rules:

        # Rationale: Nearby tests improve discoverability and encourage maintenance.
        # Tags: testing, unit-tests, structure
        - title: Co-Locate Unit Tests
          must:
            - Place unit tests next to the code they verify rather than in __tests__ directories.
            - Extend coverage to edge cases introduced by your change.

    - title: Documentation
      rules:

        # Rationale: Preserves clarity, prevents misuse, and ensures accountability in reviews.
        # Tags: lint, comments, eslint, typescript
        - title: Document Disable Directives
          must:
            - Precede any disable directive (e.g., // eslint-disable-next-line, // eslint-disable, // @ts-ignore) with a comment explaining why it is necessary and what issue it addresses.

        # Rationale: Keeps documentation in lockstep with code, preserving architectural clarity.
        # Tags: documentation, docs, consistency, architecture, maintainability
        - title: Sync Documentation with Code Changes
          should:
            - For every edited code file, update the most relevant nearest README.md when behavior or architecture changes; avoid creating duplicates—maintain the single closest, most pertinent README.
            - Verify all modified READMEs remain accurate and consistent.

        # Rationale: Provides immediate context about file purpose, improves navigation and understanding.
        # Tags: documentation, fileoverview, tsdoc
        - title: File Overview Documentation
          must:
            - Include a @fileoverview JSDoc comment at the top of every source file.
            - Describe the file's purpose, main exports, and usage context.

        # Rationale: Self-documenting code enables better IDE support, API discovery, and maintenance.
        # Tags: documentation, tsdoc, jsdoc, api
        - title: Comprehensive TSDoc/JSDoc Documentation
          must:
            - Document every export with /** */ TSDoc comments describing purpose, parameters, returns, and examples.
            - Document every class, method, and function declaration with /** */ comments, regardless of export status.
            - Include @param, @returns, @throws, and @example tags where applicable.

    - title: Project Layout & Naming
      rules:

        # Rationale: Consistent naming improves discoverability.
        # Tags: filesystem, naming, structure
        - title: Kebab-Case Project Layout
          must:
            - Use kebab-case for all directory and file names.
          should:
            - Keep layout pragmatic; avoid heavy DDD if it hurts clarity.

        # Rationale: Shortens paths, enhances discoverability, avoids repetition.
        # Tags: filesystem, naming, structure
        - title: Avoid Redundant Directory Name Prefixes
          must:
            - Do not repeat the parent directory name as a file prefix (e.g., utils/utils-helpers.ts → utils/helpers.ts).
          should:
            - Use `index.ts` for module entry points instead of duplicating directory names.
```
